@using FitskedApp.Data;
@using FitskedApp.Models;
@page "/add-plan"
@inject IUserPlanRepository PlanRepository
@inject NavigationManager NavManager
@rendermode InteractiveServer

<h3 class="d-flex justify-content-center">Add a New Plan</h3>

<p class="text-center">
    We recommend a six month plan. There will be enough variety in your weekly workouts that
    six months should provide a good balance between stashing away the time need to create a new plan
    and maintaining variety in your day-to-day workouts during the week.
</p>

<EditForm Model="@newPlan" OnValidSubmit="@AddNewPlan" FormName="AddPlanForm">
    <DataAnnotationsValidator /> <!-- Only integrates with attributes, not with something like a fluent api or fluentval nuget -->
    <ValidationSummary /> <!-- These two components work with validation with the data the UI message -->

    <div class="d-flex justify-content-center">
        <label for="PlanName">Plan Name:</label>
        <InputText class="rounded-2" id="PlanName" @bind-Value="newPlan.Name" />
        @* This is super cool. We just have to define label and inputtext for attribute and it will basically bind (not map, different concepts) to the model and ef takes care of the rest *@
    </div>

    <div class="d-flex justify-content-center">
        <label for="DurationMonths">Duration (Months):</label>
        <InputNumber class="rounded-2" id="DurationMonths" @bind-Value="newPlan.Duration" />
    </div>

    <div class="d-flex justify-content-center">
        <button href="/workout" class="rounded-2" type="submit"> Create your week </button>
    </div>


</EditForm>

@code {
    private Plan newPlan = new Plan();

    private async Task<int> AddNewPlan()
    {
        int PlanId = await PlanRepository.AddPlan(newPlan); // We need to use await here to actually have the async operations unwrap the int inside the Task<>

        newPlan = new Plan(); // Reset form after submission

        NavManager.NavigateTo($"/workout/{PlanId}");
        return PlanId;
    }
}
